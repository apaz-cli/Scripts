#if 0

# Run as a bash script.

# Create a temp dir to compile into and run out of.
TMP="$(mktemp -d)"

# Compile with nvcc if available, otherwise cc.
if command -v nvcc &> /dev/null
then
    echo "Running with nvcc."
    nvcc -o "$TMP/a.out" -x cu "$0" -O3 -lpthread && "$TMP/a.out" $@;
else
    echo "Running with cc."
    cc -o "$TMP/a.out" -x c "$0" -O3 -lpthread && "$TMP/a.out" $@;
fi

RVAL=$?;
rm -rf "$TMP";
exit $RVAL

#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <ctype.h>

#ifdef __CUDACC__
#define CUDA_CALLABLE __host__ __device__
#else
#define CUDA_CALLABLE
#define cudaMalloc(ptr, size) (*(ptr) = malloc(size), 0)
#define cudaFree(ptr) free(ptr)
#endif

#define MAX_CARDS 100
#define MAX_TAGS 10
#define MAX_TAG_LEN 32
#define MAX_LINE_LEN 256
#define HAND_SIZE 7
#define CPU_THREADS 20
#define DEFAULT_TRIALS 100000

typedef struct {
    int count;
    char tags[MAX_TAGS][MAX_TAG_LEN];
    int num_tags;
} Card;

typedef struct {
    Card cards[MAX_CARDS];
    int num_cards;
    int total_cards;
    char all_tags[MAX_TAGS][MAX_TAG_LEN];
    int num_tags;
} Deck;

typedef struct {
    int min_count[MAX_TAGS];
    int max_count[MAX_TAGS];
} TagConstraints;

typedef struct {
    Deck* deck;
    TagConstraints* constraints;
    int num_trials;
    unsigned int seed;
    int* success_count;
} SimParams;

// Fisher-Yates shuffle
CUDA_CALLABLE
void shuffle_array(int* arr, int n, unsigned int* seed) {
    for (int i = n - 1; i > 0; i--) {
        // Simple LCG random number generator
        *seed = (*seed * 1103515245 + 12345) & 0x7fffffff;
        int j = *seed % (i + 1);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

CUDA_CALLABLE
int check_hand(int* hand, int hand_size, Deck* deck, TagConstraints* constraints) {
    int tag_counts[MAX_TAGS] = {0};
    
    for (int i = 0; i < hand_size; i++) {
        Card* card = &deck->cards[hand[i]];
        for (int j = 0; j < card->num_tags; j++) {
            for (int k = 0; k < deck->num_tags; k++) {
                if (strcmp(card->tags[j], deck->all_tags[k]) == 0) {
                    tag_counts[k]++;
                }
            }
        }
    }
    
    for (int i = 0; i < deck->num_tags; i++) {
        if (tag_counts[i] < constraints->min_count[i] ||
            tag_counts[i] > constraints->max_count[i]) {
            return 0;
        }
    }
    return 1;
}

#ifdef __CUDACC__
__global__ void cuda_simulate_hands(SimParams params) {
    int tid = blockIdx.x * blockDim.x + threadIdx.x;
    int total_threads = gridDim.x * blockDim.x;
    
    // Skip if this thread isn't needed
    if (tid >= total_threads) return;
    
    int* deck_indices = (int*)malloc(params.deck->total_cards * sizeof(int));
    for (int i = 0; i < params.deck->total_cards; i++) {
        deck_indices[i] = i;
    }
    
    unsigned int local_seed = params.seed + tid;
    int local_success = 0;
    
    for (int trial = 0; trial < params.num_trials; trial++) {
        shuffle_array(deck_indices, params.deck->total_cards, &local_seed);
        if (check_hand(deck_indices, HAND_SIZE, params.deck, params.constraints)) {
            local_success++;
        }
    }
    
    atomicAdd(params.success_count, local_success);
    free(deck_indices);
}
#endif

void simulate_hands_cpu(SimParams* params) {
    int* deck_indices = (int*)malloc(params->deck->total_cards * sizeof(int));
    for (int i = 0; i < params->deck->total_cards; i++) {
        deck_indices[i] = i;
    }
    
    unsigned int local_seed = params->seed;
    int local_success = 0;
    
    for (int trial = 0; trial < params->num_trials; trial++) {
        shuffle_array(deck_indices, params->deck->total_cards, &local_seed);
        if (check_hand(deck_indices, HAND_SIZE, params->deck, params->constraints)) {
            local_success++;
        }
    }
    
    *params->success_count += local_success;
    free(deck_indices);
}

void* cpu_thread_func(void* arg) {
    SimParams* params = (SimParams*)arg;
    simulate_hands_cpu(params);
    return NULL;
}

void parse_deck(const char* filename, Deck* deck) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        fprintf(stderr, "Error opening file: %s\n", filename);
        exit(1);
    }
    
    char line[MAX_LINE_LEN];
    int in_sideboard = 0;
    deck->num_cards = 0;
    deck->total_cards = 0;
    deck->num_tags = 0;
    
    while (fgets(line, sizeof(line), file)) {
        // Skip comments and section markers
        if (line[0] == '#' || strchr(line, ':')) {
            if (strstr(line, "Sideboard:")) {
                in_sideboard = 1;
            }
            continue;
        }
        if (in_sideboard) continue;
        
        // Trim whitespace
        char* ptr = line;
        while (isspace(*ptr)) ptr++;
        if (*ptr == '\0') continue;
        
        // Parse count
        int count = 1;
        if (isdigit(*ptr)) {
            count = atoi(ptr);
            while (isdigit(*ptr)) ptr++;
        }
        
        // Parse card name and tags
        char card_name[MAX_LINE_LEN];
        char* tags[MAX_TAGS];
        int num_tags = 0;
        
        char* bracket = strchr(ptr, '[');
        if (bracket) {
            *bracket = '\0';
            strncpy(card_name, ptr, bracket - ptr);
            card_name[bracket - ptr] = '\0';
            
            ptr = bracket + 1;
            while ((bracket = strchr(ptr, '['))) {
                char* end = strchr(ptr, ']');
                if (!end) break;
                *end = '\0';
                tags[num_tags++] = strdup(ptr);
                ptr = end + 1;
            }
        } else {
            strncpy(card_name, ptr, sizeof(card_name));
        }
        
        // Add card to deck
        Card* card = &deck->cards[deck->num_cards];
        card->count = count;
        card->num_tags = num_tags;
        for (int i = 0; i < num_tags; i++) {
            strncpy(card->tags[i], tags[i], MAX_TAG_LEN);
            free(tags[i]);
            
            // Add to global tag list if new
            int found = 0;
            for (int j = 0; j < deck->num_tags; j++) {
                if (strcmp(deck->all_tags[j], card->tags[i]) == 0) {
                    found = 1;
                    break;
                }
            }
            if (!found) {
                strncpy(deck->all_tags[deck->num_tags++], card->tags[i], MAX_TAG_LEN);
            }
        }
        
        deck->num_cards++;
        deck->total_cards += count;
    }
    
    fclose(file);
    
    // Print deck summary
    printf("Deck Summary:\n");
    printf("Total cards: %d\n", deck->total_cards);
    printf("Unique cards: %d\n", deck->num_cards);
    printf("Tags found:\n");
    for (int i = 0; i < deck->num_tags; i++) {
        printf("  %s\n", deck->all_tags[i]);
    }
}

int main(int argc, char** argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <deck_file>\n", argv[0]);
        return 1;
    }
    
    Deck deck;
    parse_deck(argv[1], &deck);
    
    TagConstraints constraints;
    printf("\nEnter constraints for each tag (min max):\n");
    for (int i = 0; i < deck.num_tags; i++) {
        printf("%s: ", deck.all_tags[i]);
        scanf("%d %d", &constraints.min_count[i], &constraints.max_count[i]);
    }
    
    int success_count = 0;
    SimParams params = {
        .deck = &deck,
        .constraints = &constraints,
        .num_trials = DEFAULT_TRIALS / CPU_THREADS,
        .success_count = &success_count
    };
    
    #ifdef __CUDACC__
    // CUDA implementation
    int* d_success_count;
    cudaMalloc(&d_success_count, sizeof(int));
    cudaMemset(d_success_count, 0, sizeof(int));
    params.success_count = d_success_count;
    
    int num_blocks = 256;
    int threads_per_block = 256;
    cuda_simulate_hands<<<num_blocks, threads_per_block>>>(params);
    
    cudaMemcpy(&success_count, d_success_count, sizeof(int), cudaMemcpyDeviceToHost);
    cudaFree(d_success_count);
    #else
    // CPU implementation with pthreads
    pthread_t threads[CPU_THREADS];
    for (int i = 0; i < CPU_THREADS; i++) {
        params.seed = i; // Different seed for each thread
        pthread_create(&threads[i], NULL, cpu_thread_func, &params);
    }
    for (int i = 0; i < CPU_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    #endif
    
    float probability = (float)success_count / (DEFAULT_TRIALS);
    printf("\nProbability of meeting constraints: %.2f%%\n", probability * 100);
    
    return 0;
}
