#!/usr/bin/env python3
"""nanocode - minimal claude code alternative"""

import argparse, atexit, glob as globlib, json, os, re, readline, subprocess, sys, urllib.error, urllib.parse, urllib.request, html


# Parse args
parser = argparse.ArgumentParser(
    prog="nanocode",
    description="Minimal Claude Code alternative - an agentic coding assistant",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog="""
presets:
  --deepseek          Use DeepSeek API (requires DEEPSEEK_API_KEY)
  --glm               Use local GLM server at 127.0.0.1:9878

environment variables:
  ANTHROPIC_API_KEY   API key for Anthropic (default provider)
  OPENROUTER_API_KEY  API key for OpenRouter (auto-detected)
  DEEPSEEK_API_KEY    API key for DeepSeek (with --deepseek)
  MODEL               Override default model

commands (in chat):
  /q, exit            Quit
  /c                  Clear conversation

modes (type alone to switch):
  #                   Chat mode (default)
  !                   Command mode (next input runs as bash)
  $                   Plan mode (next input spawns planning subagent)
"""
)
preset = parser.add_mutually_exclusive_group()
preset.add_argument("--deepseek", action="store_true", help="use DeepSeek API")
preset.add_argument("--glm", action="store_true", help="use local GLM server")
parser.add_argument("--model", "-m", help="model name to use")
parser.add_argument("--base-url", dest="base_url", help="API base URL")
parser.add_argument("--api-style", dest="api_style", choices=["openai", "anthropic"], help="API style")
parser.add_argument("--dangerously-skip-permissions", action="store_true", help="skip confirmation prompts for bash commands")
parser.add_argument("--planning", nargs=3, metavar=("TASK", "CTX", "OUT"), help=argparse.SUPPRESS)
args = parser.parse_args()

# Presets and config
if args.deepseek:
    BASE_URL = "https://api.deepseek.com"
    MODEL = args.model or "deepseek-chat"
    API_KEY = os.environ.get("DEEPSEEK_API_KEY", "")
    API_STYLE = "openai"
elif args.glm:
    BASE_URL = "http://127.0.0.1:9878"
    MODEL = args.model or "glm-4.7-flash"
    API_KEY = "sk-no-key-required"
    API_STYLE = "openai"
else:
    OPENROUTER_KEY = os.environ.get("OPENROUTER_API_KEY")
    BASE_URL = args.base_url or ("https://openrouter.ai/api" if OPENROUTER_KEY else "https://api.anthropic.com")
    MODEL = args.model or os.environ.get("MODEL", "anthropic/claude-opus-4.5" if OPENROUTER_KEY else "claude-opus-4-5")
    API_KEY = OPENROUTER_KEY if OPENROUTER_KEY else os.environ.get("ANTHROPIC_API_KEY", "")
    API_STYLE = args.api_style or ("openai" if OPENROUTER_KEY else "anthropic")
if args.api_style:
    API_STYLE = args.api_style
API_URL = BASE_URL + ("/v1/chat/completions" if API_STYLE == "openai" else "/v1/messages")
SKIP_CONFIRM = args.dangerously_skip_permissions

# ANSI colors
RESET, BOLD, DIM = "\033[0m", "\033[1m", "\033[2m"
BLUE, CYAN, GREEN, YELLOW, RED = "\033[34m","\033[36m","\033[32m","\033[33m",    "\033[31m"


# --- Tool implementations ---


def read(args):
    lines = open(args["path"]).readlines()
    offset = args.get("offset", 0)
    limit = args.get("limit", len(lines))
    selected = lines[offset : offset + limit]
    return "".join(f"{offset + idx + 1:4}| {line}" for idx, line in enumerate(selected))


def write(args):
    with open(args["path"], "w") as f:
        f.write(args["content"])
    return "ok"


def edit(args):
    text = open(args["path"]).read()
    old, new = args["old"], args["new"]
    if old not in text:
        return "error: old_string not found"
    count = text.count(old)
    if not args.get("all") and count > 1:
        return f"error: old_string appears {count} times, must be unique (use all=true)"
    replacement = (
        text.replace(old, new) if args.get("all") else text.replace(old, new, 1)
    )
    with open(args["path"], "w") as f:
        f.write(replacement)
    return "ok"


def glob(args):
    pattern = (args.get("path", ".") + "/" + args["pat"]).replace("//", "/")
    files = globlib.glob(pattern, recursive=True)
    files = sorted(
        files,
        key=lambda f: os.path.getmtime(f) if os.path.isfile(f) else 0,
        reverse=True,
    )
    return "\n".join(files) or "none"


def grep(args):
    pattern = re.compile(args["pat"])
    hits = []
    for filepath in globlib.glob(args.get("path", ".") + "/**", recursive=True):
        try:
            for line_num, line in enumerate(open(filepath), 1):
                if pattern.search(line):
                    hits.append(f"{filepath}:{line_num}:{line.rstrip()}")
        except Exception:
            pass
    return "\n".join(hits[:50]) or "none"


_WEB_SEARCH_PATTERN = re.compile(
    r'class="result__a"[^>]*>(.*?)</a>'    # title
    r'.*?'                                  # stuff between
    r'class="result__snippet"[^>]*'
    r'href="([^"]+)"[^>]*>(.*?)</a>',       # href + body
    re.DOTALL
)


def web_search(args):
    query = args["query"]
    try:
        res = urllib.request.urlopen(urllib.request.Request(
            "https://html.duckduckgo.com/html/",
            urllib.parse.urlencode({"q": query}).encode(),
            {"User-Agent": "Mozilla/5.0"}
        ), timeout=10).read().decode()
    except urllib.error.HTTPError as e:
        return f"error: HTTP {e.code}: {e.reason}"
    except urllib.error.URLError as e:
        return f"error: {e.reason}"
    except TimeoutError:
        return "error: request timed out"

    def _clean_html(s):
        return html.unescape(re.sub(r'<[^>]+>', '', s)).strip()

    results = []
    for title, href, body in _WEB_SEARCH_PATTERN.findall(res):
        if href.startswith("https://duckduckgo.com/y.js?"):
            continue
        results.append({"title": _clean_html(title), "href": href, "body": _clean_html(body)})

    if not results:
        return "No results found."

    lines = []
    for i, r in enumerate(results, 1):
        lines.append(f"[{i}] {r['title']}\nURL: {r['href']}\n{r['body']}")
    return "\n\n".join(lines)


def bash(args):
    proc = subprocess.Popen(
        args["cmd"], shell=True,
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
        text=True
    )
    output_lines = []
    try:
        while True:
            line = proc.stdout.readline()
            if not line and proc.poll() is not None:
                break
            if line:
                print(f"  {DIM}│ {line.rstrip()}{RESET}", flush=True)
                output_lines.append(line)
        proc.wait(timeout=30)
    except subprocess.TimeoutExpired:
        proc.kill()
        output_lines.append("\n(timed out after 30s)")
    return "".join(output_lines).strip() or "(empty)"


# --- Tool definitions: (description, schema, function, needs_confirm) ---

def plan(a):
    ctx, out = f"/tmp/.nanocode_ctx_{os.getpid()}.json", f"/tmp/.nanocode_out_{os.getpid()}.txt"
    json.dump(_msgs, open(ctx, 'w'))
    subprocess.run(["nanocode", "--planning", a["task"], ctx, out] + (["--dangerously-skip-permissions"] if SKIP_CONFIRM else []))
    return open(out).read() if os.path.exists(out) else "Planning failed"

TOOLS = {
    "read":       ("Read file with line numbers (file path, not directory)", {"path": "string", "offset": "number?", "limit": "number?"}, read, False),
    "write":      ("Write content to file", {"path": "string", "content": "string"}, write, False),
    "edit":       ("Replace old with new in file (old must be unique unless all=true)", {"path": "string", "old": "string", "new": "string", "all": "boolean?"}, edit, False),
    "glob":       ("Find files by pattern, sorted by mtime", {"pat": "string", "path": "string?"}, glob, False),
    "grep":       ("Search files for regex pattern", {"pat": "string", "path": "string?"}, grep, False),
    "bash":       ("Run shell command", {"cmd": "string"}, bash, True),
    "web_search": ("Search the web via DuckDuckGo", {"query": "string"}, web_search, False),
    "plan":       ("Spawn a planning subagent to analyze a task and create a detailed plan", {"task": "string"}, plan, False),
}
if args.planning:
  del TOOLS["plan"]  # Prevent recurse


def run_tool(name, args):
    try:
        if TOOLS[name][3] and not SKIP_CONFIRM:  # needs_confirm
            print(f"  {YELLOW}{json.dumps(args, indent=2)}{RESET}")
            if input(f"  {YELLOW}Run? [y/N]: {RESET}").strip().lower() not in ("y", "yes"):
                return "(cancelled by user)"
        return TOOLS[name][2](args)
    except Exception as err:
        return f"error: {err}"


def make_schema():
    result = []
    for name, (desc, params, _, _) in TOOLS.items():
        props = {p: {"type": "integer" if t.rstrip("?") == "number" else t.rstrip("?")} for p, t in params.items()}
        req = [p for p, t in params.items() if not t.endswith("?")]
        schema = {"type": "object", "properties": props, "required": req}
        result.append({"type": "function", "function": {"name": name, "description": desc, "parameters": schema}} if API_STYLE == "openai"
                      else {"name": name, "description": desc, "input_schema": schema})
    return result

def to_oai(msgs):
    out = []
    for m in msgs:
        c = m["content"]
        if isinstance(c, list) and c and c[0].get("type") == "tool_result":
            out += [{"role": "tool", "tool_call_id": t["tool_use_id"], "content": t["content"]} for t in c]
        elif isinstance(c, list):
            tc = [{"id": b["id"], "type": "function", "function": {"name": b["name"], "arguments": json.dumps(b["input"])}} for b in c if b.get("type") == "tool_use"]
            out.append({"role": "assistant", "content": "".join(b.get("text", "") for b in c if b.get("type") == "text") or None, **({"tool_calls": tc} if tc else {})})
        else: out.append(m)
    return out

def from_oai(r):
    m = r["choices"][0]["message"]
    return {"content": ([{"type": "text", "text": m["content"]}] if m.get("content") else []) +
            [{"type": "tool_use", "id": t["id"], "name": t["function"]["name"], "input": json.loads(t["function"]["arguments"])} for t in m.get("tool_calls", [])]}

def call_api(messages, system_prompt):
    if API_STYLE == "openai":
        hdrs = {"Content-Type": "application/json", "Authorization": f"Bearer {API_KEY}"}
        body = {"model": MODEL, "max_tokens": 8192, "messages": [{"role": "system", "content": system_prompt}] + to_oai(messages), "tools": make_schema()}
    else:
        hdrs = {"Content-Type": "application/json", "anthropic-version": "2023-06-01", "x-api-key": API_KEY}
        body = {"model": MODEL, "max_tokens": 8192, "system": system_prompt, "messages": messages, "tools": make_schema()}
    resp = json.loads(urllib.request.urlopen(urllib.request.Request(API_URL, json.dumps(body).encode(), hdrs)).read())
    return from_oai(resp) if API_STYLE == "openai" else resp


def separator():
    return f"{DIM}{'─' * min(os.get_terminal_size().columns, 80)}{RESET}"


def render_markdown(text):
    return re.sub(r"\*\*(.+?)\*\*", f"{BOLD}\\1{RESET}", text)


_msgs = []  # global for plan tool access

def agent_loop(messages, system_prompt):
    """Run agentic loop until no more tool calls. Returns final response text."""
    while True:
        response = call_api(messages, system_prompt)
        content_blocks = response.get("content", [])
        # Retry on malformed tool call tags
        response_text = "".join(b.get("text", "") for b in content_blocks if b.get("type") == "text")
        if re.search(r"<\n+tool_call>", response_text):
            print(f"  {DIM}(retrying malformed tool_call){RESET}")
            continue
        if "<tool_call>" in response_text and response_text.count("<arg_value>") != response_text.count("</arg_value>"):
            print(f"  {DIM}(retrying mismatched tags){RESET}")
            continue
        tool_results = []
        for block in content_blocks:
            if block["type"] == "text":
                print(f"\n{CYAN}⏺{RESET} {render_markdown(block['text'])}")
            if block["type"] == "tool_use":
                name, a = block["name"], block["input"]
                print(f"\n{GREEN}⏺ {name.capitalize()}{RESET}({DIM}{str(list(a.values())[0])[:50]}{RESET})")
                result = run_tool(name, a)
                preview = result.split("\n")[0][:60] + ("..." if len(result) > 60 else "")
                if result.count("\n") > 0: preview = result.split("\n")[0][:60] + f" ... +{result.count(chr(10))} lines"
                print(f"  {DIM}⎿  {preview}{RESET}")
                tool_results.append({"type": "tool_result", "tool_use_id": block["id"], "content": result})
        messages.append({"role": "assistant", "content": content_blocks})
        if not tool_results:
            return "".join(b.get("text", "") for b in content_blocks if b["type"] == "text")
        messages.append({"role": "user", "content": tool_results})

PLAN_PROMPT = f"""You are a planning assistant. Analyze the task thoroughly and create a detailed implementation plan.
Use tools to explore the codebase and understand the problem. When done, you will be asked to summarize your plan.
cwd: {os.getcwd()}"""

def main():
    global _msgs
    if args.planning:
        task, ctx_file, out_file = args.planning
        messages = json.load(open(ctx_file)) if os.path.exists(ctx_file) else []
        _msgs = messages
        print(f"{BOLD}nanocode planning{RESET} | {DIM}{task[:50]}{RESET}\n")
        messages.append({"role": "user", "content": task})
        agent_loop(messages, PLAN_PROMPT)
        messages.append({"role": "user", "content": "Summarize your plan with all information needed to execute it."})
        result = agent_loop(messages, PLAN_PROMPT)
        open(out_file, 'w').write(result)
        return

    print(f"{BOLD}nanocode{RESET} | {DIM}{MODEL} | {os.getcwd()}{RESET}\n")
    histfile = "/tmp/.nanocode_history"
    try: readline.read_history_file(histfile)
    except FileNotFoundError: pass
    readline.set_history_length(1000)
    atexit.register(readline.write_history_file, histfile)

    messages, mode = [], "#"
    _msgs = messages
    system_prompt = f"Concise coding assistant. cwd: {os.getcwd()}"

    while True:
        try:
            print(separator())
            user_input = input(f"{BOLD}{BLUE}{mode}{RESET} ").strip()
            print(separator())
            if not user_input: continue
            if user_input in ("/q", "exit"): break
            if user_input == "/c":
                messages.clear()
                print(f"{GREEN}⏺ Cleared{RESET}")
                continue
            if user_input in ("#", "!", "$"):
                mode = user_input
                continue

            if mode == "!":
                print(bash({"cmd": user_input}))
                mode = "#"
                continue
            if mode == "$":
                result = plan({"task": user_input})
                messages.append({"role": "user", "content": f"[Plan request: {user_input}]"})
                messages.append({"role": "assistant", "content": [{"type": "text", "text": result}]})
                print(f"\n{CYAN}⏺{RESET} {render_markdown(result)}")
                mode = "#"
                continue

            messages.append({"role": "user", "content": user_input})
            agent_loop(messages, system_prompt)
            print()
        except (KeyboardInterrupt, EOFError): break
        except Exception as err: print(f"{RED}⏺ Error: {err}{RESET}")


if __name__ == "__main__":
    main()
