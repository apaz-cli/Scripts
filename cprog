#if 0

# Run as a bash script.

# Create a temp dir to compile into and run out of.
TMP="$(mktemp -d /tmp/cshebang.XXXXXXXXX)"

cc -o "$TMP/a.out" -x c "$0" -O3 -lpthread && "$TMP/a.out" $@;

RVAL=$?;
rm -rf "$TMP";
exit $RVAL

#endif


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include <limits.h>

// Template C program
const char *template_code = "#include \"cinclude.h\"\n"
                            "\n"
                            "int main(int argc, char** argv) {\n"
                            "    printf(\"Hello, World!\\n\");\n"
                            "    return 0;\n"
                            "}\n";

// Content for cinclude.h
const char *cinclude_content = "#ifndef CINCLUDE_H\n"
                               "#define CINCLUDE_H\n"
                               "\n"
                               "#include <stdio.h>\n"
                               "#include <stdlib.h>\n"
                               "#include <string.h>\n"
                               "#include <math.h>\n"
                               "#include <ctype.h>\n"
                               "#include <time.h>\n"
                               "#include <limits.h>\n"
                               "#include <float.h>\n"
                               "#include <assert.h>\n"
                               "#include <errno.h>\n"
                               "#include <locale.h>\n"
                               "#include <setjmp.h>\n"
                               "#include <signal.h>\n"
                               "#include <stdarg.h>\n"
                               "#include <stddef.h>\n"
                               "\n"
                               "#endif // CINCLUDE_H\n";

int file_exists(const char *filename) {
  struct stat buffer;
  return stat(filename, &buffer) == 0;
}

int main(int argc, char *argv[]) {
  char *temp_dir, *c_file, *cinclude_file, *output_file, *nano_cmd, *compile_cmd, *run_cmd;

  if (argc > 1) {
    // Use provided program name
    temp_dir = malloc(strlen("/tmp/cshebang.") + strlen(argv[1]) + 1);
    sprintf(temp_dir, "/tmp/cshebang.%s", argv[1]);
    
    c_file = malloc(strlen(temp_dir) + strlen(argv[1]) + 3); // +3 for "/" + ".c" + null terminator
    sprintf(c_file, "%s/%s.c", temp_dir, argv[1]);
  } else {
    // Create temporary directory
    FILE *temp = popen("mktemp -d /tmp/cshebang.XXXXXXXXX", "r");
    if (!temp) {
      fprintf(stderr, "Failed to create temporary directory\n");
      return 1;
    }
    temp_dir = malloc(100); // Assuming the temp dir name won't exceed 100 chars
    fgets(temp_dir, 100, temp);
    temp_dir[strcspn(temp_dir, "\n")] = 0; // Remove newline
    pclose(temp);

    c_file = malloc(strlen(temp_dir) + 9); // +9 for "/temp.c" + null terminator
    sprintf(c_file, "%s/temp.c", temp_dir);
  }

  // Create directory if it doesn't exist
  mkdir(temp_dir, 0755);

  // Create cinclude.h file
  cinclude_file = malloc(strlen(temp_dir) + 12); // +12 for "/cinclude.h" + null terminator
  sprintf(cinclude_file, "%s/cinclude.h", temp_dir);
  FILE *cinclude_fp = fopen(cinclude_file, "w");
  if (!cinclude_fp) {
    fprintf(stderr, "Failed to create cinclude.h file\n");
    return 1;
  }
  fprintf(cinclude_fp, "%s", cinclude_content);
  fclose(cinclude_fp);

  // Create C file with template if it doesn't exist
  if (!file_exists(c_file)) {
    FILE *fp = fopen(c_file, "w");
    if (!fp) {
      fprintf(stderr, "Failed to create C file\n");
      return 1;
    }
    fprintf(fp, "%s", template_code);
    fclose(fp);
  }

  // Open file in nano
  nano_cmd = malloc(strlen("nano ") + strlen(c_file) + 1);
  sprintf(nano_cmd, "nano %s", c_file);
  system(nano_cmd);

  // Get output file name
  output_file = malloc(strlen(temp_dir) + (argc > 1 ? strlen(argv[1]) : strlen("temp")) + 2);
  sprintf(output_file, "%s/%s", temp_dir, argc > 1 ? argv[1] : "temp");

  // Compile
  compile_cmd = malloc(strlen("gcc -o ") + strlen(output_file) + strlen(c_file) + 3);
  sprintf(compile_cmd, "gcc -o %s %s", output_file, c_file);
  if (system(compile_cmd) != 0) {
    fprintf(stderr, "Compilation failed\n");
    return 1;
  }

  // Run
  run_cmd = malloc(strlen(output_file) + 1);
  sprintf(run_cmd, "%s", output_file);
  printf("\n--- Program Output ---\n");
  system(run_cmd);

  return 0;
}
